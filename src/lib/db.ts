'use server';

import {db} from './firebase';
import {collection, addDoc, getDocs, updateDoc, deleteDoc, doc, serverTimestamp, query, orderBy} from 'firebase/firestore';

// --- Snacks ---

export interface Snack {
  id: string;
  name: string;
  category: string;
  price: number;
}

// Use 'snacks' as the collection name consistently
const snacksCollection = collection(db, 'snack');

// Input type excludes the 'id' as it's generated by Firestore
export interface SnackInput extends Omit<Snack, 'id'> {}


export async function addSnackToDb(snack: SnackInput) {
  try {
    // Ensure price is a number before saving
    const snackData = {
      ...snack,
      price: Number(snack.price) || 0, // Convert price to number, default to 0 if invalid
    };
    await addDoc(snacksCollection, snackData);
    return {success: true};
  } catch (e: any) {
    console.error('Error adding snack document: ', e);
    return {success: false, message: e.message};
  }
}

export async function updateSnackInDb(id: string, snack: SnackInput) {
  try {
    // Ensure price is a number before updating
    const snackData = {
        ...snack,
        price: Number(snack.price) || 0, // Convert price to number
    };
    const snackDoc = doc(db, 'snacks', id); // Use 'snacks' collection
    await updateDoc(snackDoc, snackData);
    return {success: true};
  } catch (e: any) {
    console.error('Error updating snack document: ', e);
    return {success: false, message: e.message};
  }
}

export async function deleteSnackFromDb(id: string) {
  try {
    const snackDoc = doc(db, 'snacks', id); // Use 'snacks' collection
    await deleteDoc(snackDoc);
    return {success: true};
  } catch (e: any) {
    console.error('Error deleting snack document: ', e);
    return {success: false, message: e.message};
  }
}

export async function getSnacksFromDb(): Promise<Snack[]> {
  try {
    console.log("Attempting to fetch snacks from Firestore collection 'snacks'...");
    const snackSnapshot = await getDocs(snacksCollection); // Use 'snacks' collection
    console.log(`Fetched ${snackSnapshot.docs.length} snack documents.`);
    const snacks = snackSnapshot.docs.map(doc => {
        const data = doc.data();
        // Ensure price is treated as a number
        const price = Number(data.price);
        if (isNaN(price)) {
            console.warn(`Document ${doc.id} has invalid price: ${data.price}. Setting price to 0.`);
        }
        return {
          id: doc.id,
          name: data.name || 'Unnamed Snack', // Provide default values if fields are missing
          category: data.category || 'Uncategorized',
          price: isNaN(price) ? 0 : price, // Default to 0 if price is not a valid number
        } as Snack;
    });
    console.log("Mapped snacks:", snacks);
    return snacks;
  } catch (e: any) {
    console.error('Error getting snack documents: ', e);
    // Return empty array or throw error based on desired behavior
    return [];
  }
}


// --- Bills ---

export interface BillItem {
    name: string;
    price: number;
    quantity: number;
}

export interface Bill {
    id: string; // Firestore document ID
    orderNumber: string;
    items: BillItem[];
    serviceCharge: number;
    totalAmount: number;
    createdAt: any; // Firestore Timestamp
}

export interface BillInput extends Omit<Bill, 'id' | 'createdAt'> {}

const billsCollection = collection(db, 'bills');

export async function addBillToDb(bill: BillInput) {
    try {
      await addDoc(billsCollection, {
        ...bill,
        createdAt: serverTimestamp() // Add server timestamp
      });
      return {success: true};
    } catch (e: any) {
      console.error('Error adding bill document: ', e);
      return {success: false, message: e.message};
    }
}

export async function getBillsFromDb(): Promise<Bill[]> {
    try {
      // Order bills by creation date, newest first
      const billsQuery = query(billsCollection, orderBy('createdAt', 'desc'));
      const billSnapshot = await getDocs(billsQuery);
      return billSnapshot.docs.map(doc => {
        const data = doc.data();
        return {
          id: doc.id,
          ...data,
          // Convert Firestore Timestamp to Date object or string if needed
          // createdAt: data.createdAt?.toDate() // Optional chaining in case createdAt is missing
        } as Bill;
      })
    } catch (e: any) {
      console.error('Error getting bill documents: ', e);
      return [];
    }
}
