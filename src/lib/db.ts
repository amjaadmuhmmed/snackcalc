
'use server';

import {db} from './firebase';
import {collection, addDoc, getDocs, updateDoc, deleteDoc, doc, serverTimestamp, query, orderBy, Timestamp, runTransaction, DocumentReference} from 'firebase/firestore';

// --- Items (formerly Snacks) ---

export interface Snack { // Internal interface name remains Snack for now
  id: string;
  name: string;
  category: string;
  price: number;
  cost?: number;
  itemCode?: string;
  stockQuantity: number; // New field for stock
}

// Input type excludes the 'id' as it's generated by Firestore
export interface SnackInput extends Omit<Snack, 'id'> {}

const itemsCollection = collection(db, 'snack'); // 'snack' is the collection name in Firestore

export async function addItemToDb(item: SnackInput) {
  try {
    const itemData = {
      ...item,
      price: Number(item.price) || 0,
      cost: item.cost !== undefined ? Number(item.cost) : undefined,
      itemCode: item.itemCode || '',
      stockQuantity: Number(item.stockQuantity) || 0, // Initialize stock
    };
    await addDoc(itemsCollection, itemData);
    return {success: true};
  } catch (e: any) {
    console.error('Error adding item document: ', e);
    return {success: false, message: e.message};
  }
}

export async function updateItemInDb(id: string, item: Partial<SnackInput>) { // Allow partial updates for stock
  try {
    const itemData: any = {};
    if (item.name !== undefined) itemData.name = item.name;
    if (item.price !== undefined) itemData.price = Number(item.price) || 0;
    if (item.category !== undefined) itemData.category = item.category;
    if (item.cost !== undefined) itemData.cost = item.cost !== null ? Number(item.cost) : undefined; // Corrected to handle null for optional parsing
    if (item.itemCode !== undefined) itemData.itemCode = item.itemCode || '';
    if (item.stockQuantity !== undefined) itemData.stockQuantity = Number(item.stockQuantity) || 0;

    if (Object.keys(itemData).length === 0) {
      return { success: true, message: "No fields to update." };
    }

    const itemDoc = doc(db, 'snack', id);
    await updateDoc(itemDoc, itemData);
    return {success: true};
  } catch (e: any) {
    console.error('Error updating item document: ', e);
    return {success: false, message: e.message};
  }
}

export async function deleteItemFromDb(id: string) {
  try {
    const itemDoc = doc(db, 'snack', id);
    await deleteDoc(itemDoc);
    return {success: true};
  } catch (e: any) {
    console.error('Error deleting item document: ', e);
    return {success: false, message: e.message};
  }
}

export async function getItemsFromDb(): Promise<Snack[]> {
  try {
    const itemsQuery = query(itemsCollection, orderBy('name')); // Optionally order by name
    const itemSnapshot = await getDocs(itemsQuery);
    return itemSnapshot.docs.map(docSnap => {
        const data = docSnap.data();
        const price = Number(data.price);
        const cost = data.cost !== undefined ? Number(data.cost) : undefined;
        const stockQuantity = Number(data.stockQuantity);

        if (isNaN(price)) {
            console.warn(`Document ${docSnap.id} has invalid price: ${data.price}. Setting price to 0.`);
        }
        if (data.cost !== undefined && isNaN(cost!)) {
            console.warn(`Document ${docSnap.id} has invalid cost: ${data.cost}. Setting cost to undefined.`);
        }
        if (isNaN(stockQuantity)) {
            console.warn(`Document ${docSnap.id} has invalid stockQuantity: ${data.stockQuantity}. Setting stock to 0.`);
        }
        return {
          id: docSnap.id,
          name: data.name || 'Unnamed Item',
          category: data.category || 'Uncategorized',
          price: isNaN(price) ? 0 : price,
          cost: data.cost !== undefined && !isNaN(cost!) ? cost : undefined,
          itemCode: data.itemCode || '',
          stockQuantity: isNaN(stockQuantity) ? 0 : stockQuantity,
        } as Snack;
    });
  } catch (e: any) {
    console.error('Error getting item documents: ', e);
    return [];
  }
}

// Helper to get a single item, useful for stock checks if needed later or direct updates.
// Not strictly required for the current stock update logic in saveBill if saveBill fetches old bill.
// export async function getItemById(itemId: string): Promise<Snack | null> {
//     try {
//         const itemDocRef = doc(db, 'snack', itemId);
//         const itemSnap = await getDoc(itemDocRef);
//         if (itemSnap.exists()) {
//             const data = itemSnap.data();
//             return {
//                 id: itemSnap.id,
//                 name: data.name,
//                 price: Number(data.price),
//                 category: data.category,
//                 cost: data.cost !== undefined ? Number(data.cost) : undefined,
//                 itemCode: data.itemCode || '',
//                 stockQuantity: Number(data.stockQuantity) || 0,
//             } as Snack;
//         }
//         return null;
//     } catch (error) {
//         console.error(`Error fetching item ${itemId}:`, error);
//         return null;
//     }
// }


// --- Bills ---

export interface BillItem {
    itemId: string; // Store item ID to link back to the item for stock
    name: string;
    price: number; // Selling price
    quantity: number;
    itemCode?: string;
}

export interface Bill {
    id: string; // Firestore document ID
    orderNumber: string;
    customerName?: string;
    customerPhoneNumber?: string;
    tableNumber?: string;
    notes?: string;
    items: BillItem[];
    serviceCharge: number;
    totalAmount: number;
    createdAt: Timestamp | Date;
    lastUpdatedAt?: Timestamp | Date;
}

export interface BillInput extends Omit<Bill, 'id' | 'createdAt' | 'lastUpdatedAt'> {}

const billsCollection = collection(db, 'bills');

export async function addBillToDb(bill: BillInput) {
    try {
      const docRef = await addDoc(billsCollection, {
        ...bill,
        customerName: bill.customerName || '',
        customerPhoneNumber: bill.customerPhoneNumber || '',
        tableNumber: bill.tableNumber || '',
        notes: bill.notes || '',
        createdAt: serverTimestamp()
      });
      return {success: true, id: docRef.id};
    } catch (e: any) {
      console.error('Error adding bill document: ', e);
      return {success: false, message: e.message, id: undefined };
    }
}

export async function updateBillInDb(id: string, bill: BillInput) {
    try {
        const billDoc = doc(db, 'bills', id);
        await updateDoc(billDoc, {
            ...bill,
            customerName: bill.customerName || '',
            customerPhoneNumber: bill.customerPhoneNumber || '',
            tableNumber: bill.tableNumber || '',
            notes: bill.notes || '',
            lastUpdatedAt: serverTimestamp()
        });
        return {success: true};
    } catch (e: any) {
        console.error('Error updating bill document: ', e);
        return {success: false, message: e.message};
    }
}

// export async function getBillById(billId: string): Promise<Bill | null> {
//     try {
//         const billDocRef = doc(db, 'bills', billId);
//         const billSnap = await getDoc(billDocRef); // getDoc is imported from 'firebase/firestore'
//         if (billSnap.exists()) {
//             const data = billSnap.data();
//             const itemsWithCode = (data.items || []).map((item: any) => ({
//                 itemId: item.itemId || '', 
//                 name: item.name || 'Unknown Item',
//                 price: Number(item.price) || 0,
//                 quantity: Number(item.quantity) || 0,
//                 itemCode: item.itemCode || '',
//             }));
//             return {
//                 id: billSnap.id,
//                 ...data, // Spread other bill properties
//                 items: itemsWithCode,
//                 // Ensure all Bill interface fields are present
//                 orderNumber: data.orderNumber,
//                 serviceCharge: data.serviceCharge,
//                 totalAmount: data.totalAmount,
//                 createdAt: data.createdAt,
//                 lastUpdatedAt: data.lastUpdatedAt,
//             } as Bill;
//         }
//         return null;
//     } catch (error) {
//         console.error(`Error fetching bill ${billId}:`, error);
//         return null;
//     }
// }


export async function getBillsFromDb(): Promise<Bill[]> {
    try {
      const billsQuery = query(billsCollection, orderBy('createdAt', 'desc'));
      const billSnapshot = await getDocs(billsQuery);
      return billSnapshot.docs.map(docSnap => {
        const data = docSnap.data();
        const itemsWithCode = (data.items || []).map((item: any) => ({
          itemId: item.itemId || '', 
          name: item.name || 'Unknown Item',
          price: Number(item.price) || 0,
          quantity: Number(item.quantity) || 0,
          itemCode: item.itemCode || '',
        }));

        return {
          id: docSnap.id,
          orderNumber: data.orderNumber,
          customerName: data.customerName || '',
          customerPhoneNumber: data.customerPhoneNumber || '',
          tableNumber: data.tableNumber || '',
          notes: data.notes || '',
          items: itemsWithCode,
          serviceCharge: data.serviceCharge,
          totalAmount: data.totalAmount,
          createdAt: data.createdAt,
          lastUpdatedAt: data.lastUpdatedAt,
        } as Bill;
      })
    } catch (e: any) {
      console.error('Error getting bill documents: ', e);
      return [];
    }
}

// Firestore transaction to update stock quantities
export async function updateStockQuantitiesForBill(
    dbItemsToUpdate: Array<{ itemId: string; quantityChange: number }>
): Promise<{ success: boolean; message?: string }> {
    if (dbItemsToUpdate.length === 0) {
        return { success: true };
    }
    try {
        await runTransaction(db, async (transaction) => {
            for (const { itemId, quantityChange } of dbItemsToUpdate) {
                if (!itemId) {
                    console.warn("Skipping stock update for an item without an ID.");
                    continue;
                }
                const itemDocRef = doc(db, 'snack', itemId); // 'snack' is the collection name
                const itemDoc = await transaction.get(itemDocRef);

                if (!itemDoc.exists()) {
                    console.error(`Item with ID ${itemId} not found for stock update.`);
                    throw new Error(`Item with ID ${itemId} not found during stock update.`);
                }

                const currentStock = Number(itemDoc.data().stockQuantity) || 0;
                const newStock = currentStock - quantityChange; // quantityChange is positive for sale (deduct), negative for return (add back)
                transaction.update(itemDocRef, { stockQuantity: newStock });
            }
        });
        return { success: true };
    } catch (error: any) {
        console.error('Stock update transaction failed: ', error);
        return { success: false, message: error.message || 'Stock update transaction failed.' };
    }
}

// Helper to get a document snapshot from Firestore
// This is mainly used in actions.ts to fetch documents before updating
import { getDoc } from 'firebase/firestore';
export { getDoc }; // Re-export getDoc for use in actions.ts

    