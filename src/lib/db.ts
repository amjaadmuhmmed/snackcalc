'use server';

import {db} from './firebase';
import {collection, addDoc, getDocs, updateDoc, deleteDoc, doc, serverTimestamp, query, orderBy, Timestamp} from 'firebase/firestore';

// --- Snacks ---

export interface Snack {
  id: string;
  name: string;
  category: string;
  price: number;
}

// Use 'snack' as the collection name consistently
const snacksCollection = collection(db, 'snack');

// Input type excludes the 'id' as it's generated by Firestore
export interface SnackInput extends Omit<Snack, 'id'> {}


export async function addSnackToDb(snack: SnackInput) {
  try {
    // Ensure price is a number before saving
    const snackData = {
      ...snack,
      price: Number(snack.price) || 0, // Convert price to number, default to 0 if invalid
    };
    await addDoc(snacksCollection, snackData);
    return {success: true};
  } catch (e: any) {
    console.error('Error adding snack document: ', e);
    return {success: false, message: e.message};
  }
}

export async function updateSnackInDb(id: string, snack: SnackInput) {
  try {
    // Ensure price is a number before updating
    const snackData = {
        ...snack,
        price: Number(snack.price) || 0, // Convert price to number
    };
    const snackDoc = doc(db, 'snack', id); // Use 'snack' collection, was 'snacks'
    await updateDoc(snackDoc, snackData);
    return {success: true};
  } catch (e: any) {
    console.error('Error updating snack document: ', e);
    return {success: false, message: e.message};
  }
}

export async function deleteSnackFromDb(id: string) {
  try {
    const snackDoc = doc(db, 'snack', id); // Use 'snack' collection, was 'snacks'
    await deleteDoc(snackDoc);
    return {success: true};
  } catch (e: any) {
    console.error('Error deleting snack document: ', e);
    return {success: false, message: e.message};
  }
}

export async function getSnacksFromDb(): Promise<Snack[]> {
  try {
    console.log("Attempting to fetch snacks from Firestore collection 'snack'..."); // was 'snacks'
    const snackSnapshot = await getDocs(snacksCollection); // Use 'snack' collection
    console.log(`Fetched ${snackSnapshot.docs.length} snack documents.`);
    const snacks = snackSnapshot.docs.map(docSnap => { // Renamed doc to docSnap to avoid conflict
        const data = docSnap.data();
        // Ensure price is treated as a number
        const price = Number(data.price);
        if (isNaN(price)) {
            console.warn(`Document ${docSnap.id} has invalid price: ${data.price}. Setting price to 0.`);
        }
        return {
          id: docSnap.id,
          name: data.name || 'Unnamed Snack', // Provide default values if fields are missing
          category: data.category || 'Uncategorized',
          price: isNaN(price) ? 0 : price, // Default to 0 if price is not a valid number
        } as Snack;
    });
    console.log("Mapped snacks:", snacks);
    return snacks;
  } catch (e: any) {
    console.error('Error getting snack documents: ', e);
    // Return empty array or throw error based on desired behavior
    return [];
  }
}


// --- Bills ---

export interface BillItem {
    name: string;
    price: number;
    quantity: number;
}

export interface Bill {
    id: string; // Firestore document ID
    orderNumber: string;
    customerName?: string; // Optional customer name
    customerPhoneNumber?: string; // Optional customer phone number
    tableNumber?: string; // Optional table number
    notes?: string; // Optional notes
    items: BillItem[];
    serviceCharge: number;
    totalAmount: number;
    createdAt: Timestamp | Date; // Firestore Timestamp or Date
    lastUpdatedAt?: Timestamp | Date; // Optional: Firestore Timestamp or Date for updates
}

export interface BillInput extends Omit<Bill, 'id' | 'createdAt' | 'lastUpdatedAt'> {}

const billsCollection = collection(db, 'bills');

export async function addBillToDb(bill: BillInput) {
    try {
      const docRef = await addDoc(billsCollection, {
        ...bill,
        customerName: bill.customerName || '',
        customerPhoneNumber: bill.customerPhoneNumber || '',
        tableNumber: bill.tableNumber || '',
        notes: bill.notes || '', // Save notes
        createdAt: serverTimestamp() // Add server timestamp
      });
      return {success: true, id: docRef.id}; // Return the new document ID
    } catch (e: any) {
      console.error('Error adding bill document: ', e);
      return {success: false, message: e.message};
    }
}

export async function updateBillInDb(id: string, bill: BillInput) {
    try {
        const billDoc = doc(db, 'bills', id);
        await updateDoc(billDoc, {
            ...bill,
            customerName: bill.customerName || '',
            customerPhoneNumber: bill.customerPhoneNumber || '',
            tableNumber: bill.tableNumber || '',
            notes: bill.notes || '',
            lastUpdatedAt: serverTimestamp() // Set last updated timestamp
        });
        return {success: true};
    } catch (e: any) {
        console.error('Error updating bill document: ', e);
        return {success: false, message: e.message};
    }
}


export async function getBillsFromDb(): Promise<Bill[]> {
    try {
      // Order bills by creation date, newest first
      const billsQuery = query(billsCollection, orderBy('createdAt', 'desc'));
      const billSnapshot = await getDocs(billsQuery);
      return billSnapshot.docs.map(docSnap => { // Renamed doc to docSnap
        const data = docSnap.data();
        return {
          id: docSnap.id,
          orderNumber: data.orderNumber,
          customerName: data.customerName || '',
          customerPhoneNumber: data.customerPhoneNumber || '',
          tableNumber: data.tableNumber || '',
          notes: data.notes || '', // Retrieve notes
          items: data.items,
          serviceCharge: data.serviceCharge,
          totalAmount: data.totalAmount,
          createdAt: data.createdAt,
          lastUpdatedAt: data.lastUpdatedAt,
        } as Bill;
      })
    } catch (e: any) {
      console.error('Error getting bill documents: ', e);
      return [];
    }
}
